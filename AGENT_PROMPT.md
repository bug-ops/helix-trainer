# AGENT_PROMPT: Helix Keybindings Trainer

## Вашей задаче - разработать интерактивный тренажер для изучения горячих клавиш Helix

Вы работаете в составе Rust-команды, разрабатывающей образовательный инструмент. Ваша роль - реализовать компоненты согласно плану в Claude.md.

---

## ПРИНЦИПЫ РАБОТЫ

1. **Используйте готовые решения**: не пишите велосипеды. Используйте экосистему Rust для готовых компонентов.
2. **Модульность**: каждый компонент должен быть независимым и тестируемым.
3. **Типобезопасность**: максимально используйте типы Rust для предотвращения ошибок.
4. **Ясность кода**: хорошо структурированный код с понятными именами и комментариями.
5. **Итеративность**: начните с MVP, затем расширяйте функциональность.

---

## ЭТАП 1: FOUNDATION (MVP)

### Задача 1.1: Инициализация проекта

**Что делать:**

- [ ] Создайте новый Rust проект: `cargo init helix-trainer`
- [ ] Добавьте необходимые зависимости в Cargo.toml:

  ```toml
  [dependencies]
  ratatui = "0.28"
  crossterm = "0.28"
  tokio = { version = "1", features = ["full"] }
  serde = { version = "1.0", features = ["derive"] }
  toml = "0.8"
  tracing = "0.1"
  tracing-subscriber = "0.3"
  anyhow = "1.0"
  thiserror = "1.0"
  
  [dev-dependencies]
  tokio-test = "0.4"
  ```

- [ ] Создайте структуру директорий согласно документации
- [ ] Добавьте .gitignore и README.md

**Критерии успеха:**

- Проект компилируется
- Структура модулей корректна
- `cargo build --release` работает без ошибок

---

### Задача 1.2: Система загрузки сценариев

**Что делать:**

- [ ] Создайте модуль `src/config/` с подмодулем `scenarios.rs`
- [ ] Разработайте структуры данных Scenario согласно TOML формату:

  ```rust
  #[derive(Deserialize, Debug, Clone)]
  pub struct Scenario {
      pub id: String,
      pub name: String,
      pub description: String,
      pub setup: Setup,
      pub target: TargetState,
      pub solution: Solution,
      pub alternatives: Vec<AlternativeSolution>,
      pub hints: Vec<String>,
      pub scoring: ScoringConfig,
  }
  ```

- [ ] Реализуйте функцию загрузки TOML файла:

  ```rust
  pub fn load_scenarios(path: &Path) -> anyhow::Result<Vec<Scenario>>
  ```

- [ ] Добавьте обработку ошибок (файл не найден, неверный формат)
- [ ] Напишите unit-тесты для парсинга

**Критерии успеха:**

- Можно загружать TOML файл
- Структуры корректно десериализуются
- Тесты проходят

---

### Задача 1.3: Модель редактора (EditorState)

**Что делать:**

- [ ] Создайте модуль `src/game/editor_state.rs`
- [ ] Реализуйте структуру EditorState:

  ```rust
  #[derive(Clone, Debug, PartialEq)]
  pub struct EditorState {
      pub content: String,
      pub cursor_pos: (usize, usize),  // (row, col)
  }
  
  impl EditorState {
      pub fn new(content: String) -> Self { }
      pub fn line_count(&self) -> usize { }
      pub fn get_line(&self, row: usize) -> Option<&str> { }
      pub fn move_cursor_to(&mut self, row: usize, col: usize) { }
      pub fn delete_line(&mut self, row: usize) { }
      pub fn insert_text(&mut self, text: &str) { }
  }
  ```

- [ ] Добавьте методы для базовых операций редактирования
- [ ] Напишите unit-тесты для каждого метода

**Критерии успеха:**

- Все операции работают корректно
- Тесты проходят
- Нет паник при граничных значениях

---

### Задача 1.4: Система подсчёта очков (Scorer)

**Что делать:**

- [ ] Создайте модуль `src/game/scorer.rs`
- [ ] Реализуйте логику подсчёта очков:

  ```rust
  pub struct Scorer;
  
  impl Scorer {
      pub fn calculate_score(
          optimal_count: usize,
          actual_count: usize,
          max_points: u32,
      ) -> u32 {
          // Если пользователь использовал столько же или меньше команд - 100%
          // Иначе пропорционально
      }
      
      pub fn get_feedback(
          actual: usize,
          optimal: usize,
          alternative_solutions: &[AlternativeSolution],
      ) -> String {
          // Возвращает текст обратной связи
      }
  }
  ```

- [ ] Добавьте функции для анализа решения
- [ ] Напишите тесты для различных сценариев

**Критерии успеха:**

- Формула подсчёта очков логична и справедлива
- Обратная связь информативна
- Тесты всех граничных случаев проходят

---

### Задача 1.5: Игровой двигатель (GameSession)

**Что делать:**

- [ ] Создайте модуль `src/game/scenario.rs`
- [ ] Реализуйте структуру GameSession:

  ```rust
  pub struct GameSession {
      scenario: Scenario,
      current_state: EditorState,
      user_actions: Vec<UserAction>,
      started_at: Instant,
      completed: bool,
  }
  
  impl GameSession {
      pub fn new(scenario: Scenario) -> Self { }
      pub fn apply_action(&mut self, action: UserAction) -> Result<()> { }
      pub fn check_completion(&self) -> bool { }
      pub fn calculate_score(&self) -> u32 { }
      pub fn get_hint(&self) -> &str { }
      pub fn get_solution(&self) -> &Solution { }
  }
  ```

- [ ] Напишите логику проверки завершения задачи
- [ ] Интегрируйте Scorer для подсчёта очков

**Критерии успеха:**

- Сессия корректно отслеживает состояние
- Проверка завершения работает
- Интеграция со Scorer работает

---

### Задача 1.6: Базовый TUI (Menu)

**Что делать:**

- [ ] Создайте модуль `src/ui/` с подмодулем `menu.rs`
- [ ] Реализуйте главное меню с использованием ratatui:

  ```
  ┌─────────────────────────┐
  │  HELIX TRAINER          │
  ├─────────────────────────┤
  │  [→] Start Training     │
  │  [ ] Statistics         │
  │  [ ] Settings           │
  │  [ ] Quit               │
  └─────────────────────────┘
  ```

- [ ] Добавьте навигацию (стрелки вверх/вниз, Enter для выбора)
- [ ] Реализуйте возврат в меню

**Критерии успеха:**

- Меню отрисовывается корректно
- Навигация работает
- Приложение не паникует при нажатии клавиш

---

### Задача 1.7: Экран задачи (TaskScreen)

**Что делать:**

- [ ] Создайте модуль `src/ui/task_screen.rs`
- [ ] Отобразите:

  ```
  ┌──────────────────────────────────┐
  │ Task: Delete current line         │
  │ Difficulty: ★☆☆                  │
  ├──────────────────────────────────┤
  │ Description:                     │
  │ Удалить текущую строку, где      │
  │ находится курсор                 │
  ├──────────────────────────────────┤
  │ Current state:                   │
  │ > first line                     │
  │ | second line (cursor here)      │
  │ | third line                     │
  ├──────────────────────────────────┤
  │ Actions: 0 | Optimal: 2          │
  │                                  │
  │ [H]int  [S]olution  [Skip] [Q]uit│
  └──────────────────────────────────┘
  ```

- [ ] Интегрируйте с GameSession
- [ ] Отобразите счётчик действий

**Критерии успеха:**

- Экран отрисовывается корректно
- Состояние редактора отображается правильно
- Кнопки функционируют

---

### Задача 1.8: Экран результатов (ResultsScreen)

**Что делать:**

- [ ] Создайте модуль `src/ui/results.rs`
- [ ] Отобразите:

  ```
  ┌──────────────────────────────────┐
  │ COMPLETED ✓                      │
  ├──────────────────────────────────┤
  │ Score: 95 / 100                  │
  │ Actions: 2 / 2 (optimal!)        │
  │ Time: 45 seconds                 │
  │                                  │
  │ Ideal solution:                  │
  │ > 'd', 'd'                       │
  │                                  │
  │ Alternative solutions:           │
  │ > 'Ctrl-K'                       │
  ├──────────────────────────────────┤
  │     [Next Task]  [Main Menu]     │
  └──────────────────────────────────┘
  ```

- [ ] Интегрируйте с GameSession для получения данных

**Критерии успеха:**

- Результаты отображаются корректно
- Обратная связь информативна

---

### Задача 1.9: Основной цикл приложения

**Что делать:**

- [ ] Создайте `src/main.rs` с основным цикл приложения:

  ```rust
  #[tokio::main]
  async fn main() -> anyhow::Result<()> {
      // Инициализация
      // Основной цикл обработки событий
      // Обработка нажатий клавиш
      // Переходы между экранами
  }
  ```

- [ ] Реализуйте обработку Ctrl+C для выхода
- [ ] Добавьте логирование через tracing

**Критерии успеха:**

- Приложение запускается и не паникует
- Можно нормально выйти
- Можно переходить между экранами

---

### Задача 1.10: Создание TOML сценариев

**Что делать:**

- [ ] Создайте директорию `scenarios/`
- [ ] Напишите `scenarios/basic.toml` с 5-10 базовыми задачами:
  - Удаление строки (d, d)
  - Перемещение курсора (j, k, h, l)
  - Вставка текста
  - Выделение (v)
  - Копирование (y)

**Критерии успеха:**

- TOML файлы валидны
- Сценарии логичны и прогрессируют по сложности

---

## ЭТАП 2: HELIX INTEGRATION

### Задача 2.1: PTY Controller

**Что делать:**

- [ ] Создайте модуль `src/helix/pty_controller.rs`
- [ ] Реализуйте запуск Helix процесса:

  ```rust
  pub struct HelixPTY {
      process: PtyProcess,
  }
  
  impl HelixPTY {
      pub fn new(file_path: &Path) -> anyhow::Result<Self> { }
      pub fn send_command(&mut self, cmd: &str) -> anyhow::Result<()> { }
      pub fn get_buffer_content(&self) -> anyhow::Result<String> { }
      pub fn close(&mut self) -> anyhow::Result<()> { }
  }
  ```

**Примечание**: это сложная часть, может потребоваться специальная обработка Helix output.

---

### Задача 2.2: Command Tracker

**Что делать:**

- [ ] Создайте модуль `src/helix/command_tracker.rs`
- [ ] Отслеживайте входные команды и сравнивайте с target state

---

## ЭТАП 3: POLISH & FEATURES

После завершения Этапов 1-2 добавьте:

- Система прогресса и статистики
- Уровни сложности
- Система достижений
- Export статистики в JSON

---

## ПРАВИЛА РАЗРАБОТКИ

### Структурирование кода

```
- Каждый модуль отвечает за одну ответственность
- Используйте типы для моделирования домена
- Минимизируйте pub API каждого модуля
```

### Обработка ошибок

```rust
// Используйте anyhow::Result<T> для публичных функций
// Используйте thiserror для пользовательских ошибок
// Никогда не используйте unwrap() в production коде
```

### Тестирование

```
- Минимум unit-тесты для каждого модуля
- Integration тесты для взаимодействия компонентов
- Тесты граничных случаев (empty strings, zero, max values)
```

### Документация

```
- Комментарии /// для публичного API
- Примеры использования в комментариях
- README для каждого модуля (опционально)
```

---

## ИСПОЛЬЗОВАНИЕ ИНСТРУМЕНТОВ

### Проверка качества кода

```bash
cargo fmt              # Форматирование
cargo clippy           # Линтер
cargo test             # Тесты
cargo build --release  # Release сборка
```

### Debug

```bash
RUST_LOG=debug cargo run   # С логированием
```

---

## КРИТЕРИИ ПРИЁМА ЗАДАЧИ

Каждая задача считается выполненной когда:

1. ✅ Код компилируется без ошибок и warning'ов
2. ✅ Все unit-тесты проходят
3. ✅ Функциональность работает согласно описанию
4. ✅ Код следует style guide и лучшим практикам Rust
5. ✅ Документация актуальна

---

## КОГДА ОБРАЩАТЬСЯ ЗА УТОЧНЕНИЯМИ

- Если требования задачи неясны
- Если архитектурное решение непонятно
- Если нужно выбирать между альтернативами
- Если возникли блокирующие технические проблемы

---

## ПРИОРИТИЗАЦИЯ

**Высокий приоритет:**

1. Задачи Этапа 1 (Foundation) - это MVP
2. Работающее приложение, которое можно запустить
3. Корректное тестовое покрытие

**Средний приоритет:**

- Оптимизация performance
- Улучшение UI/UX

**Низкий приоритет:**

- Кэширование
- Advanced logging

---

## ДОПОЛНИТЕЛЬНЫЕ РЕСУРСЫ

- Документация ratatui: <https://docs.rs/ratatui/latest/ratatui/>
- Crossterm: <https://docs.rs/crossterm/latest/crossterm/>
- Rust Book: <https://doc.rust-lang.org/book/>
- Tokio Runtime: <https://tokio.rs/>

---

## НАЧНИТЕ С ЗАДАЧИ 1.1

Инициализируйте проект и создайте структуру директорий. Это даст хороший фундамент для остальной разработки.

**Удачи! 🚀**
